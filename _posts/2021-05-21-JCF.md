---
title:  "JCF"
excerpt: "Java Collection Framework"

categories:
  - java
  - 스터디
last_modified_at: 2020-05-21T08:06:00-05:00
---

![image](https://user-images.githubusercontent.com/25449640/119110926-89b50980-ba5d-11eb-8672-24996bd15ccf.png)
(ref : www.testingpool.com )

# JCF 에는 뭐가 있는가?

- 크게 보자면 Collection 인터페이스와 Map 인터페이스로 나눌 수 있습니다.

- 자세하게는 Collection.List, Collection.Set, Collection.Queue, java.util.Map 가 있습니다.

- Collection 의 조상에는 Iterable 이 있고 이 인터페이스는 디폴트 메소드 `forEach()`, `spliterator()` 와 내부 반복자가 있습니다.

- 반면에 Map 은 Iterable 을 상속받고 있지 않기 때문에 내부 반복자가 없습니다. 

- `List` 는 순서가 있으며 중복을 허용하지만 `Set` 은 순서가 없고 중복을 허용하지 않습니다.

- `Map` 은 key-value 구조로 되어 있으며 key 는 중복을 허용하지 않습니다.

- `Set` 을 까보면 `Set` 은 `Map` 을 활용한 자료구조입니다. `HashSet` 은 `HashMap` 을 `TreeSet` 은 `TreeMap` 을 `LinkedHashSet` 은 `LinkedHashMap` 을 사용합니다. `Map` 인터페이스에서 key 만 사용하고 value 는 모두 동일한 더미값을 넣어 사용하지 않습니다. `Map` 인터페이스에는 getKey() 메소드가 없는데 이러한 이유로 `Set` 에도 get() 메소드가 구조적으로 존재하지 않습니다.

- `Queue` 는 먼저들어온 것이 먼저 나가는 자료구조입니다.


# List

- 리스트는 순서가 있는 데이터의 집합으로 데이터의 중복을 허용합니다.

- ArrayList : 순서가 있는 데이터 집합으로, 인덱스를 이용하여 엘리먼트를 관리하는 점이 배열과 유사합니다. 하지만 배열의 단점인 한번 생성하면 길이를 변경 할 수 없는 것을 보완하여 길이를 동적으로 할당 할 수 있습니다. 저장용량을 넘어서면 크기가 50% 증가합니다. 동기화 되어 있지 않습니다. 참고로 `Arrays` 클래스는 JCF 가 아니라 정적 메소드를 제공해 배열을 다루기 쉽게 도와주는 `util` 입니다. 일반적으로 탐색/정렬이 작업을 주로 한다면 ArrayList 자료구조를 사용합니다.

- Vector : ArrayList 와 비슷하지만 동기화 되어있습니다. 하지만 Vector 인스턴스에 대해서는 동기화 처리가 되어있지 않고 메소드들에만 동기화 처리되어 있어 Vector 자체가 쓰레드 세이프하다고는 하기 어렵습니다. 그래서 Vector 를 다루는 부분은 `synchronized` 키워드로 처리를 해주어야 쓰레드 세이프 합니다. 다만 ArrayList 또한 `Collections.synchronizedlist()` 를 통해 동기화 된 리스트로 만들어 줄 수 있기에 Vector 를 쓸 이유는 굳이 없습니다.

- LinkedList : Queue 인터페이스를 구현한 자료구조입니다. 따라서 `FIFO` 방식을 따릅니다. 각 엘리먼트를 인덱스로 관리하지 않고 노드로 관리합니다. 노드에는 엘리먼트와 다음 노드의 주소를 가리키는 포인터가 있습니다. 선형구조인 list 의 단점 중인 하나인 중간 엘리먼트의 삽입/삭제 시 오버헤드가 큰 점을 보완한 자료구조입니다. 삽입/삭제가 많을 시 ArrayList 보다 성능이 좋습니다.

- Stack : Vector 를 상속받는 자료구조입니다. `LIFO` 방식을 따릅니다. 이 자료구조도 굳이 사용되지 않고 있습니다. (Vector 와 같은 이유로)

# Set

# Queue

# Map
