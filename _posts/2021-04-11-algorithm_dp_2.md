---
title:  "다이나믹 프로그래밍"
excerpt: "DP 2번 문제"

categories:
  - Algorithm
tags:
  - Java
last_modified_at: 2021-04-12T08:06:00-05:00
---


```java
2번 문제

N가지 종류(배열)의 화폐가 있다.이 화폐의 개수를 최소한으로 사용하여 그 가치의 합이 M 이 되도록 해야한다.
M 원을 만들기 위한 최소한의 화폐개수를 출력해라.
불가능일 때에는 -1 을 출력한다.

1 <= M <= 10,000
1 <= N <= 100

EX) N = [2,3] M = 15 -> 5
N = [3,5,7] M = 4 -> -1
```

```java
2번 문제 해답

최적 부분 구조와 중복되는 부분 문제를 찾는다.

EX) N = [2,3,5] M = 7 일 때 
dp[8] 을 만들고 0 번째 인덱스에는 0을, 나머지 인덱스에는 10,001 로 초기화 한다.(M 이 10,000 이하이니)
각각의 인덱스는 i 원을 만들 수 있는 N 화폐의 개수이다.

각각의 화페 단위를 확인하면서 모든 금액에 대한 옵티멀 솔루션을 구한다.
O(N^2)   

화폐 2 부터 살펴본다.
dp[0] = 0
dp[1] = 10,001 // 1 원을 만드는 방법 없기에 그대로 둔다
dp[2] = 1
dp[3] = 10,001
dp[4] = 2 // 4 원을 만드는 방법은 2 원 x 2
dp[5] = 10,001
dp[6] = 3
dp[7] = 10,001

화폐 3 을 살펴보고 위의 dp 배열에 업데이트한다.
dp[3] = 1
dp[4] = 2 // dp[4] 인 2 하고 dp[1] + 1 인 10,002 하고 비교
dp[5] = 10,001  // dp[5] 인 10,001 하고 dp[1] + 1 인 10,002 하고 비교
dp[6] = 2 // dp[6] 인 3 하고 dp[2] + 1 인 2 하고 비교
dp[7] = 3 // dp[4] 가 10,001 이 아닌 2 이기 때문에 이 수에 + 1을 한 값을 넣을 수 있다.

화페 5 를 살펴본다.
dp[5] = 1
dp[6] = 2 // dp[6] 인 2 하고 dp[1] + 1 인 10,002 하고 비교
dp[7] = 2 // dp[2] 가 1 이므로 dp[7] 은 dp[2] + 1 인 2 로 업데이트 된다.

최종적으로 답은 dp[7] 의 값인 2가 리턴된다.


class int solution(int[] N, int M) {

     int[] dp = new int[M + 1];
    Arrays.fill(dp, 10001);
    dp[0] = 0;

     for(int i = 0; i < N.length; i++) {
        for(int j = N[i]; j <= M; j++) {
            if(dp[j - N[i]] != 10001) {
                dp[j] = Math.min(dp[j], dp[j - N[i]] + 1);
            }
        }
    }
    for(int i = 0; i < M; i++) {
        log.info (i + "번째" + dp[i]);
    }
    if (dp[M] == 10001) {
        return -1;
    }

     return dp[M];
}


```
