---
title:  "다이나믹 프로그래밍"
excerpt: "DP란 무엇일까?"

categories:
  - Algorithm
tags:
  - Java
last_modified_at: 2021-04-11T08:06:00-05:00
---

```java
1번 문제

정수 x 가 주어졌을 때, 정수 x 에 사용할 수 있는 연산은 다음과 같은 4가지이다.

1. x 가 5로 나누어 떨어지면 5로 나눈다.
2. x 가 3으로 나누어 떨어지면 3으로 나눈다.
3. x 가 2로 나누어 떨어지면 2로 나눈다.
4. x 에서 1을 뺀다.

1 <= x <= 30,000

정수 x 가 주어졌을 때 연산 4가지를 적절히 사용하여 1을 만들고자 한다.
연산을 최소한 사용하여 1을 만드는 회수를 구하시오.
EX) 26 -> 25 -> 5 -> 1
```

```java
1번 문제 해답

최적 부분 구조와 중복되는 부분 문제가 있는지 파악한다.

EX) x 가 6 일 때,
x 에서 1을 뺀 케이스 5
x 에서 3으로 나눈 케이스 2
x 에서 2로 나눈 케이스 3
총 3가지로 부분 문제를 만들 수 있고

5 는 
1을 뺀 케이스 4
5로 나눈 케이스 1

2 는
1을 뺀 케이스 1
2로 나눈 케이스 1

3 은
1을 뺀 케이스 2 -> 위에서 이미 계산한 중복되는 부분 문제 발생
3으로 나눈 케이스 1

4 는
1을 뺀 케이스 3 -> 부분 문제 
2로 나눈 케이스 2 -> 부분 문제

1) 최적 부분 구조 : 위의 예와 같이 6 은 5 2 3 으로 부분 구조가 만들어지므로 성립 됨
2) 중복 부분 문제 : 있음

x 를 1로 만들기 위한 최소 연산 횟수는
ax = min(ax/5, ax/3, ax/2, ax-1) + 1 로 점화식을 만들 수 있다.
이 때 1 을 빼는 경우는 무조건 수행되며 나누기의 경우에는 나누기를 가능한 경우에만 점화식을 적용할 수 있다.

a1 = 1 이다.
a6 = min(a2, a3, a5) + 1

1. a2 = min(a1, a1) + 1 = 2
2. a3 = min(a1, a2) + 1 = 2
3. a5 = min(a1, a4) + 1 = 2

a6 = min(2,2,2) + 1
이므로 3 이다

class int soulution(int x) {

  int[] dp = new int[30001];

  // 바텀업 방식의 dp
  for(int i = 1; i < x; i++) {
    dp[i] = dp[i - 1] + 1;

    if (i % 5 == 0) {
      d[i] = Math.min(dp[i], d[i/5] + 1);
    } else if (i % 2 == 0) {
      d[i] = Math.min(dp[i], d[i/2] + 1);
    } else if (i % 3 == 0) {
      d[i] = Math.min(dp[i], d[i/3] + 1);
    }
  }

  return dp[x - 1];

}

```


```java
2번 문제

N가지 종류(배열)의 화폐가 있다.이 화폐의 개수를 최소한으로 사용하여 그 가치의 합이 M 이 되도록 해야한다.
M 원을 만들기 위한 최소한의 화폐개수를 출력해라.
불가능일 때에는 -1 을 출력한다.

1 <= M <= 10,000
1 <= N <= 100

EX) N = [2,3] M = 15 -> 5
N = [3,5,7] M = 4 -> -1
```

```java
2번 문제 해답

최적 부분 구조와 중복되는 부분 문제를 찾는다.

EX) N = [2,3,5] M = 7 일 때 
dp[8] 을 만들고 0 번째 인덱스에는 0을, 나머지 인덱스에는 10,001 로 초기화 한다.(M 이 10,000 이하이니)
각각의 인덱스는 i 원을 만들 수 있는 N 화폐의 개수이다.

화폐 2 부터 살펴본다.
dp[0] = 0
dp[1] = 10,001 // 1 원을 만드는 방법 없기에 그대로 둔다
dp[2] = 1
dp[3] = 10,001
dp[4] = 2 // 4 원을 만드는 방법은 2 원 x 2
dp[5] = 10,001
dp[6] = 3
dp[7] = 10,001

화폐 3 을 살펴보고 위의 dp 배열에 업데이트한다.
dp[3] = 1
dp[6] = 2
dp[7] = 3 // dp[4] 가 10,001 이 아닌 2 이기 때문에 이 수에 + 1을 한 값을 넣을 수 있다.

화페 5 를 살펴본다.
dp[5] = 1
dp[7] = 2 // dp[2] 가 1 이므로 dp[7] 은 dp[2] + 1 인 2 로 업데이트 된다.

최종적으로 답은 dp[7] 의 값인 2가 리턴된다.


class int solution(int[] N, int M) {

     int[] dp = new int[M + 1];
    Arrays.fill(dp, 10001);
    dp[0] = 0;

     for(int i = 0; i < N.length; i++) {
        for(int j = N[i]; j <= M; j++) {
            if(dp[j - N[i]] != 10001) {
                dp[j] = Math.min(dp[j], dp[j - N[i]] + 1);
            }
        }
    }
    for(int i = 0; i < M; i++) {
        log.info (i + "번째" + dp[i]);
    }
    if (dp[M] == 10001) {
        return -1;
    }

     return dp[M];
}


```