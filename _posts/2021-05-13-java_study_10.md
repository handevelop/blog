---
title:  "JAVA 스터디 10주차"
excerpt: "멀티쓰레드 프로그래밍"

categories:
  - Java
  - 스터디
tags:
  - Java
last_modified_at: 2021-05-13T08:22:00-05:00
---

# Process 와 Thread 차이

- 프로세스란 OS 에서 실행중인 `하나의 프로그램을 부르는 단위`.

![제목 없음](https://user-images.githubusercontent.com/25449640/118156989-f7a57380-b454-11eb-8b56-d85b9a8fae9d.jpg)

- 쓰레드란 이 프로세스 안에서 갖는 `작업의 흐름 단위`.

- 멀티 쓰레드란 말은 하나의 프로세스가 여러개의 쓰레드를 갖고 있으며 한 프로세스 안에서 동시에 여러가지 작업을 할 수 있게 해준다.

- 멀티 프로세스는 각각의 프로세스가 OS 로부터 독립된 메모리를 할당 받기 때문에 VS CODE 에 문제가 생겨 프로세스가 죽었다 하더라도 IE 는 그대로 있다.

- 반면 멀티 쓰레드 환경에서는 하나의 쓰레드가 문제가 생기면 다른 쓰레드에도 영향을 끼칠 수 있다.

- CPU 코어 1개에 여러개의 쓰레드가 실행되는 것을 동시성(concurrency), 코어 별로 개별 쓰레드가 실행되는 것을 병렬성(parallelism) 이라 한다. 멀티 쓰레드는 이 두가지를 모두 고려해야 한다.

- 1개의 코어당 1개의 쓰레드를 갖는다는 병렬성.

- 1개의 코어에서 여러개의 쓰레드를 갖고, 코어는 각각의 쓰레드를 순식간에 번갈아 가면서 처리하는 것이 동시성.


# Thread 클래스와 Runnable 인터페이스

- 자바에서 쓰레드를 생성할 때 사용하는 것들.

- `Thread` 클래스를 상속받게 되면 `다른 클래스를 상속받을 수 없기 때문에` 보통 `Runnalbe` 인터페이스를 구현하여 쓰레드를 사용한다.

- 또한 `Thread` 클래스는 `Runnable` 인터페이스 구현 객체를 전달 받을 수 있기 때문에 객체를 재사용 할 수 있다는 점도 있다.

```java
class MyThread extends Thread {
  @override
  public void run() {
    log.info("using Thread extends...");
  }
}
...
// Runnable 을 사용한 쓰레드 사용법
Thread myThread = new Thread(() -> {
  // run 메소드 내용이 들어간다
  log.info("using lambda Thread...");
});

// Thread 클래스를 상속 받은 클래스로 쓰레드 사용법
Thread myThread2 = new MyThread();

myThread.start();
myThread2.start();

```


# 쓰레드의 상태

- 멀티 쓰레드 프로그래밍에서 자원과 시간을 여러 쓰레드가 낭비하지 않고 잘 사용하도록 하기위해 쓰레드의 상태를 아는것이 중요하다.

- `getState()` 메소드를 통해 쓰레드 상태를 알 수 있다.

## NEW

- 쓰레드가 생성되고 아직 `start()` 가 호출되지 않은 상태.

## RUNNABLE

- 실행 대기 상태.

## BLOCKED

- 동기화 블럭에 의해 일시정지된 상태.

## WAITING, TIMED_WAITING

- 쓰레드의 작업이 종료되지는 않았지만 실행 가능하지 않은 일시정지 상태.

- `TIMED_WAITING` 은 일시정지 시간이 지정되어 있는 일시정지 상태.

## TERMINATED

- 쓰레드의 작업이 종료된 상태.

## 쓰레드의 상태를 제어하는 메소드

- `interrupt()` : 자신이 일시정지 상태가 되었을 때 `InterruptedException` 을 발생시킴.

- `join()` : 독립적인 쓰레드일지더라도 어떤 쓰레드의 작업이 먼저 끝나고 다른 쓰레드의 작업이 수행되야 하는 등의 동기화가 필요할 때 사용하는 메소드. 

- `sleep()` : 일정 시간 동안 일시정지 시킴.

- `yield()` : 자신과 레이스 컨디션에 놓여있는 다른 쓰레드 중 자신보다 우선순위가 높은 쓰레드가 더 많이 실행할 수 있도록 양보함.

- `wait()` : 쓰레드를 일시 정지 상태 시킴.

- `notify()` : `wait()` 에 의해 일시 정지된 쓰레드를 실행 대기 상태로 바꿈.

- `notifyAll()` : 일시 정지된 모든 쓰레드를 실행 대기 상태로 바꿈.


# 쓰레드의 우선순위

- 동시성에 의해 1 개의 코어에서 여러개의 쓰레드가 수행 될 때 어떤 규칙을 갖고 어떤 쓰레드를 더 많이 수행할지 결정하는 것을 `스케쥴링` 이라 한다.

- `스케쥴링` 에는 `우선순위` 방식과 `Round Robin` 방식이 있다.

- `우선순위` 방식 : 우선순위가 더 높은 쓰레드가 더 많은 실행 시간을 가짐. 우선순위는 1 ~ 10 까지 부여가능하다. 10 이 가장 우선순위가 높다. (default : 5)

- `Round Robin` 방식 : 자원을 점유하는 시간이 정해져 있고 서로 돌아가면서 그 시간동안 실행하는 방식.


# Main 쓰레드

- 자바 어플리케이션은 `Main 쓰레드` 를 가지고 있다. 모든 쓰레드는 메인 쓰레드로부터 생성된다.

- main 메소드로부터 시작하는 쓰레드이며 실제로 아래 명령어로 확인해보면 `main` 메소드명이 나온다.

```java
public static void main(String[] args) {
  log.info("현재 쓰레드 : " + Thread.currentThread().getName());
}
// main
```


# 동기화

- 쓰레드는 프로세스와 다르게 공유 자원을 사용하므로 쓰레드 사용시 유의해야 한다.

- 그 중에서도 객체가 올라가 있는 `Heap 영역` 에 접근할 때 `동기화` 를 사용하면서 공유 객체에 접근이 필요한 경우가 있다.

- 예를 들어 계좌에 잔액이 10000원이 있는데 3개의 ATM 에서 동시에 10000원을 인출한다면? 이런 상황에서 30000원이 인출되는 현상을 막기위해 `동기화` 가 필요하다.

- `synchronized` 키워드를 통해 메소드에 붙여서 동기화 시킬 수 있다. 이렇게 되면 메소드 전체에 임계 영역을 걸게 된다.

- 또는 `동기화 블록` 을 만들어 사용도 가능하다. `동기화 블록` 을 사용하면 임계 영역을 만나기 전까지 동시 호출이 가능하다는 점이 `동기화 메소드` 와의 차이점이 있다.

```java
class Account {
  private int money = 10000;

  public void withdraw(int input) {
    // 동기화 블록 시작
    synchronized(this) {
      if (this.money < input) {
        log.info("잔액 부족");
        return;
      }

      try {
        Thread.sleep(1000);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }

      log.info("찾은 금액 : " + input);
      this.money -= input;
    }
  }
}
```


# 데드락

- 공유 객체에 대해 다수의 쓰레드가 서로 실행이 끝나기를 기다리고 있는 `교착 상태` 이다.

- 예를 들어 1 번 쓰레드와 2 번 쓰레드가 동시에 실행되어 각각 A 와 B 자원을 점유했다. 그리고 1 번 쓰레드는 B 자원에 접근하고 2 번 쓰레드는 A 자원에 접근하려고 하는 로직이 있을 때, A 자원은 1 번 쓰레드에 의해 점유되어있고 B 자원은 2 번 쓰레드에 의해 점유되어 있어서 서로 무한히 대기 상태로 있게 된다.