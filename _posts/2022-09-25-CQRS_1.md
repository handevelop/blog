---
title:  "CQRS"
excerpt: ""

categories:
  - java
  - 스터디
last_modified_at: 2022-09-25T21:06:00-05:00
---


# CQRS 란?

- CQRS 란 Command and Query Responsibility Segregation 의 약자로 CRUD 에서 CUD 가 되는 명령(커맨드)와 R 가 되는 읽기(쿼리)의 책임을 분리하는 패턴이다.
- CQS 원칙을 기반으로 만들어진 패턴이라고 알고있다.
- 단순히 CQRS 단독으로 구성하지 않고 보통은 이벤트 소싱 패턴, Materialized View 패턴과 함께 사용되는 것 같다.
- 아무튼, 왜 명령과 쿼리를 분리하는 이런 패턴이 나왔을까 생각을 해보면 서비스가 너무 복잡해지면서 필연적으로 등장했던것 같다.


# 모놀리식, MSA 그리고 CQRS

- 하나의 거대한 애플리케이션 그리고 그 애플리케이션에서 접근 가능한 수많은 DB 와 테이블. 
- 수번의 join 과 몇백줄에 이르는 거대한 쿼리가 주를 이루었던 모놀리식 아키텍처.
- 애플리케이션을 각 도메인에 맞게 여러 마이크로 서비스로 쪼개고 각 마이크로 서비스마다 DB 를 별도로 두고 API 로 통신하는 방식의 MSA. (물론 EDA 를 곁들여 이벤트를 활용하기도 하고, 서비스를 적게 쪼개기도 하고 DB join 도 적당히 허용하는 MSA 가 일반적이긴 하다.)
- MSA 로 넘어와서 거대한 join 이 필요없게 되었지만 서비스가 복잡해지면서 원하는 뷰 뿐 아니라 여러가지 불필요한 데이터들도 넘어오게 된다.
- CQRS 가 이때 적절한 해답이 될 수 있을 것 같다.


# Materialized View 패턴

![image](https://user-images.githubusercontent.com/25449640/193414061-099869e3-aaf8-447a-b8ee-5689260824b1.png)
- 메테리얼라이즈드 뷰란 여러개의 데이터 저장소에 있는 데이터들을 이상적인 포맷으로 미리 생성해 둔 뷰를 말한다.
- 이로인해 효율적인 쿼리와 데이터 추출에 도움이 된다.


# 이벤트 소싱 패턴

- 이벤트 스토어를 두고, 데이터의 생성/변경/삭제 등의 이벤트가 발생할 때마다 이벤트를 이벤트 스토어에 저장한다.
- 저장된 데이터는 메시지 브로커를 활용하여 비동기로 메시지 pub/sub 이 일어나 DB 들을 동기화 시킨다.
- 예를 들면 검색결과 창에 노출하는 상품평가 개수를 동기화 하기 위해 상품평가 작성/삭제 시에 상품번호, 작성/삭제 구분값 등을 이벤트 스토어에 저장하고, 이를 구독하고 있는 검색 개발팀에서는 그 상품의 상품평가 개수를 동기화 하는 작업을 하게 된다.
- 검색개발팀 입장에서도 상품평가 개수를 위한 API 호출을 하는것이 부담(사실은 서로가 부담)스러웠는데 이제는 검색개발팀 만의 DB 혹은 위에서 말한 메테리얼라이즈드 뷰를 이용해 쿼리의 용이성 및 성능의 향상 두마리 토끼를 잡을 수 있게 되었다.


# CQRS 맛보기

![image](https://user-images.githubusercontent.com/25449640/193414792-74ec3a41-317d-44c4-b74c-2dfcc7688aab.png)

- Command 서버, Query 서버를 분리하여 CUD / R 을 각각 담당하게 했다. 평상 시 CUD TPS 는 채 50이 안되었고, R TPS 는 300~400 정도였기에 Command 파드를 더 적게, Query 파드를 더 많이 두었다.
- Command API 서버에는 몽고DB, RDB 와 카프카를 구성.
- Query API 서버에는 몽고DB 로 구성.
- 상품평가 사이즈 정보 등록/업데이트/삭제는 모두 커맨드 서버를 통해 이루어지고 이 때 메테리얼라이즈드 뷰를 통해 쿼리를 위한 뷰를 만들어주었다.
- 또한 최초로 사이즈 정보가 등록될 때 카프카 메시지 큐에 사이즈 정보를 적재하여 비동기로 해당 회원이 이전에 작성한 상품평가 들에 대해서도 사이즈 정보를 등록하는 구조를 만들었다. 


# 느낀점

- 경험해본 CQRS 패턴의 장점은 다음과 같다.
- 확실히 조회할 때 좋다. 원하는 데이터가 오라클, DynamoDB, MongoDB 등등 그 어떤 DB 에 있더라도 메테리얼라이즈드 뷰가 저장된 DB만 조회해서 그 결과만 리턴하면 된다. 만약 여러개의 DB 를 사용하면서 API 가 느려져서 캐싱, 튜닝 등등 다 해봤지만 해결이 어렵다면 메테리얼라이즈드 뷰를 도입해보는 것을 추천한다.
- CUD 때도 좋다. CUD API 는 적절한 값들을 데이터 스토어에 넘기고 CUD 에만 신경 쓰면 된다.
- 메시지를 구독하는 곳에서 DB 동기화, 메테리얼라이즈드 뷰 작성을 하기 때문에 CRUD API 로직은 굉장히 간단해진다.

- 당연히 단점도 있을터. 내가 느낀 단점을 다음과 같다.
- 카프카 등 이벤트 소싱 패턴에 사용하는 메시지 브로커를 사용할 때의 주의점을 잘 지켜야 한다. 멱등성이라든지..
- 원천 DB, 메테리얼라이즈드 뷰, 메시지 브로커 등 관리 포인트가 늘어난다. 데이터가 중복으로 저장되는것도 누군가는 싫어할테고, 관리 포인트가 많기에 어디선가 장애가 났는지 포인트가 늘어나는것이 흠이다.


# 도입하기 전에 꼭 생각해봐야 하는 점

- 원본 데이터가 단순하고 쿼리하기 용이한 경우에는 굳이 도입할 필요X
- 원본 데이터가 굉장히 빠르게 변경되는 경우 이벤트 - 메시지 consume 순서 관리, 뷰 만들기와 관련된 처리 오버헤드가 오히려 더 커진다.
- 도입하려는 서비스의 일관성이 중요한 경우에는 적합하지 않을것 같다.뷰는 원본 데이터와 완벽하게 일치하지 않을 수 있다.