---
title:  "JAVA 스터디 2주차"
excerpt: "자바 데이터 타입, 변수 그리고 배열"

categories:
  - Java
  - 스터디
tags:
  - Java
last_modified_at: 2021-04-06T08:22:00-05:00
---

# 프리미티브 타입 종류와 값의 범위 그리고 기본 값

- primitive type. 원시 타입 혹은 기본형 타입이라고 한다.

- 자바의 8대 자료형이라고 하며 byte, short, int, long, float, double, boolean, char 형이 있다.

![image](https://user-images.githubusercontent.com/25449640/113721507-8f16f880-972a-11eb-8e41-e84f51872484.png)

(ref : https://blog.naver.com/hsm622/222144931396)

- 위 표를 보면 int 형은 4 byte. 즉 2^32 인데 왜 범위가 0 ~ 4294967296 가 아닌 -2147483648 ~ 2147483647 까지일까?

- 그 이유는 컴퓨터는 수를 표현할 때 첫번째 비트를 음수인지 양수인지를 결정하는 Most Significant Bit(MSB) 로 사용하기 때문이다.

- 그래서 11111111 ~ 11111111 은 -2147483648 이고 01111111 ~ 11111111 은 2147483647 의 범위를 갖게 되는것.

- 그런데 왜 이렇게 프리미티브 타입에는 여러가지의 자료형이 있을까?

- 그 이유는 메모리의 공간을 효율적으로 사용하기 위해서이다. 고작 3 byte 를 사용하는데 long 형을 사용하면 5 byte 나 낭비가 된다. 

- 또 하나 알고 넘어가야 하는 점은 JVM 의 스택에 메모리를 쌓는 단위가 4 byte 이다. 그렇기 때문에 배열이 아닌 단독으로 사용할 때에는 byte 나 short 형을 쓰기보다는 int 형으로 사용하는게 더 효율 적이다. (byte 형으로 변수를 지정해도 저장 할 때 4 byte 로 변환한다!)


# 프리미티브 타입과 레퍼런스 타입

- 위에서 살펴본 것처럼 프리미티브 타입이란 기본형을 말한다.

- 레퍼런스 타입이란 참조 타입이라고 하며 모든 자료형에서 프리미티브 자료형을 뺀 나머지 자료형이라고 할 수 있다. 배열, enum, 클래스, 인터페이스 가 그 예이다.

## 프리미티브 타입 VS 레퍼런스 타입

    - 프리미티브 타입 : 변수에 그 값이 저장된다. 값은 JVM 의 런타임 데이터 영역 중 스택 영역에 저장되어 있다.

    - 레퍼런스 타입 : 변수에는 값이 들어있는 주소값만 저장된다. 값은 JVM 의 런타임 데이터 영역 중 힙 영역에 저장되어 있다.


# 리터럴

- 그 자체로 값을 의미한다. 메모리에 저장되어 있는 변하지 않는 값을 리터럴이라 한다.

- 프리미티브 타입으로 리터럴을 만들 수 있다. 이 때, 접두/접미사를 붙여서 명시적으로 타입을 표기해주는게 좋다.

- 기본형 외에도 불변 클래스일 경우에도 리터럴을 만들 수 있다. 그 예로 문자열(String)이 있다.

```java
String literal = "리터럴입니다."; // "리터럴입니다." 가 리터럴이다. (정확히는 문자열 리터럴)
```

## 리터럴 VS 상수

    - 리터럴 : 대입 연산자 기준으로 우항에 있는 값을 리터럴이라 한다. 그 자체로 값을 의미한다.

    - 상수 : 변하지 않는 변수. 보통 선언할 때 일반 변수와 구분을 위해 대문자와 언더 스코어로 표기한다.

    ```java
    final String CONSTANT_STRING = "상수";
    final int CONSTANT_INT = 777;
    ```


# 변수 선언 및 초기화하는 방법

- 변수의 종류는 인스턴스 변수, 클래스 변수, 지역 변수, 매개 변수가 있다. 인스턴스 변수와 클래스 변수를 통틀어 클래스의 멤버 변수라고 한다.

- 인스턴스 변수 : 클래스에 static 없이 선언된 변수. 인스턴스 별로 값을 다르게 줄 수 있다.

- 클래스 변수 : 클래스에 static 으로 선언된 변수. 모든 인스턴스가 공유함.

- 지역 변수 : 메서드 선언 사이에 존재하는 변수. 다른 클래스는 접근 불가.

- 매개 변수 : 메서드의 인자로 전달되는 변수.

- 멤버변수는 초기화 해주지 않아도 초기값으로 셋팅이 되지만 지역 변수는 초기화가 필요하다.

- 변수 선언 방법은 아래와 같다.

```java
int i;
char a, b, c; // 여러개를 동시에 선언
```

- 변수를 초기화 하는 방법은 아래와 같다.

```java
int i = 10; // 선언과 동시에 초기화
char a, b, c;
a = 'a'; // 선언 후 초기화
```

- 선언과 동시에 초기화 하는것과 선언 후 초기화 하는 행위 모두 바이트코드 상으로는 동일한 명령어로 수행된다.

- 배열의 경우에는 아래와 같이 선언/초기화 힌다.

```java
int[] arr;
String[] strArr = new String[5];
String[] weeks = {"월","화","수","목","금","토","일"};
```

- 프리미티브 타입의 배열은 엘리먼트 초기값을 갖고 있지만, 참조형의 배열 선언 후 엘리먼트 초기값은 null 인것을 주의.

```java
int[] intArr = new int[5];
// intArr[0]; <<- 0
Student[] studentArr = new Student[5];
// studentArr[0]; <<- null
```


# 변수의 스코프와 라이프타임


- 인스턴스 변수 : static 블록과 static 메소드를 제외한 클래스 전체. 인스턴스가 생성되고 죽기 까지가 라이프타임.

- 클래스 변수 : 클래스 전체. 클래스가 초기화되고 프로그램이 종료될때까지가 라이프타임.

- 지역 변수 : 변수가 선언된 블록 내부. 변수 선언 이후 블록을 벗어날때까지.

- 만약 아래와 같이 클래스 변수와 지역 변수의 명이 같다면 지역 변수의 값이 출력 된다. (좁은 범위에서 먼저 변수를 찾고 점차 스코프를 넓힘)

```java
class A {
    int i = 10;

    public void getNumber() {
        int i = 20;
        System.out.println("i = " + i); // 20
    }
}

```


# 타입 변환, 캐스팅 그리고 타입 프로모션

- 타입 변환이란 특정 데이터 타입으로 표현된 리터럴을 다른 타입으로 변환하는 것을 말한다.

- 타입 변환으로 크게 타입 캐스팅, 타입 프로모션이 있다.

- 이 때 데이터 타입의 크기가 아닌 표현 범위로 캐스팅인지, 프로모션인지 구분해야 한다.

- 타입 캐스팅 : 자신의 표현 범위를 모두 포함하지 않은 데이터 타입으로의 변환. 호환되지 않는 타입이더라도 형 변환을 강제할 수 있다.

- 타입 프로모션 : 자신의 표현 범위를 모두 포함한 데이터 타입으로의 변환.

```java
// 타입 캐스팅 예시
float pi = 3.14f;
long longPi = pi; // compile error
long longPi = (long) pi; // 타입 캐스팅

System.out.prinlnt(pi); // 3.14
System.out.prinlnt(longPi); // 3. pi 의 표현 범위를 모두 포함하지 않은 데이터 타입으로 변환. (4 byte -> 8 byte 로 데이터 크기는 늘어났다는 것에 주목.)

// 호환되지 않는 타입의 타입 캐스팅 예시
char c = 'c';
int num = 88;
c = (char) num;

System.out.prinlnt(c); // X 아스키코드 88은 X.

// 타입 프로모션 예시
long longNum = 123L;
float floatNum = longNum; // 타입 프로모션

System.out.prinlnt(longNum); // 123
System.out.prinlnt(floatNum); // 123.0 longNum 의 표현 범위를 모두 포함한 데이터 타입으로 변환. (8 byte -> 4 byte 로 줄었지만 타입 프로모션이다.)
```

## 오토박싱과 언박싱

- 오토박싱 : 프리미티브 타입에서 Wrapper 클래스로 자동 변환 되는 것.

- 언박싱 : Wrapper 타입에서 프리미티브 타입으로 변환 되는 것.

```java
Integer integer = 1; // Integer integer = Integer.valueOf(1); 과정이 알아서 컴파일러가 진행. 이 과정을 오토박싱이라 함.

int i = integer; // Wrapper 타입에서 프리미티브 타입으로 변환.
```


# 1차원 및 2차원 배열 선언하기

- 배열도 객체이기 때문에 new 로 생성한다. 즉, 힙 영역에 생성된다.

- 1차원 배열 선언
```java
int[] intArr1 = new int[10]; // 각 요소는 0 으로 초기화 된다.
int[] intArr2 = new int[] {1,2,3,4,5}; // 길이 5 로 추론하여 생성.
int[] intArr3 = {6,7,8,9,10}; // 길이 5 로 추론하여 생성.
```

- 2차원 배열 선언
```java
int[][] intArr = new int[10][10];
String[][] strArr1 = new String[10][10]; // 프리미티브 타입과는 다르게 이 때 각 요소들은 null 이다.
String[][] strArr2 = new String[10][]; // 이런식으로 요소의 길이를 지정하지 않아도 된다. 이 때 각 요소들은 null 이다.
strArr2[0] = new String[5]; // 각 요소의 배열마다 초기화
strArr2[1] = new String[10]; // 요소마다 크기를 다르게 할 수 있다.
```


# 타입 추론, var

- var 는 타입추론을 위해 java 10 부터 추가된 기능.

- var 는 로컬변수이면서 선언할 때 값이 할당 되어야 한다. 그래야 추론을 할 수 있다.

- 또한 람다식에서도 사용할 수 없으며, null 로 초기화 할 수 없다.

```java
var i = 10L;
```

- 제네릭의 이점도 사용할 수 없으니 주의해야 한다.

```java
var list = new ArrayList<>(); // ArrayList<Object> 로 컴파일 된다.
```