---
title:  "JAVA 스터디 3주차"
excerpt: "자바가 제공하는 다양한 연산자"

categories:
  - Java
  - 스터디
tags:
  - Java
last_modified_at: 2021-04-07T08:22:00-05:00
---


# 산술 연산자

- 산술 연산자는 사칙연산자(+, -, *, /) 와 나머지 연산자(%) 로 구성되어 있다.

- 산술 연산자를 사용함에 있어 주의해야 할 것은 크게 2가지이다.

- 첫번째, 형변환 : 피연산자의 타입중 범위가 더 넓은 타입으로 형변환 된다.
```java
int i = 5;
int j = 2;

System.out.pritnln(i / j); // 2.5 가 아니라 2 가 출력

float f = 2.0f;

System.out.pritnln(i / f); // 2.5 출력. 범위가 더 넓은 타입으로 형변환 된다

```

- 두번째, 오버플로우 : 피연산자의 타입에 신경써야 한다.
```java
int i = 100_000_000; // 100000000 와 같은 수. 10억
int j = 100_000_000;

long l = i * j;
System.out.pritnln(l); // -12315414 출력. long 에서 충분히 i * j 를 표현할 수 있음에도 i * j 는 int 이기 때문에 오버플로우가 났다.

```


# 비트 연산자

- 비트 연산자는 ~, &, |, ^ 로 구성되어 있다.

- 일상생활에서 많이 쓰이는 서브넷 마스크에서 사용 중이다.

- ~ : NOT

- & : AND

- | : OR

- ^ : XOR

```java
byte num1 = 10; // 00001010
byte num2 = 15; // 00001111

System.out.pritnln(~num1); // 11110101 -> -128 + 64 + 32 + 16 + 4 + 1 -> -11. 부호를 바꾸고 -1 을 해준것과 같다.

System.out.pritnln(num1 & num2); // 00001010 -> 10

System.out.pritnln(num1 | num2); // 00001111 -> 15

System.out.pritnln(num1 ^ num2); // 00000101 -> 5
```

## 쉬프트 연산자

- 비트 연산자처럼 두개의 피연산자가 변수라면, 쉬프트 연산자는 변수와 수의 조합으로 사용한다.

- << 와 >> 가 있다. 

- << 는 왼쪽으로 쉬프트하고 >> 는 오른쪽으로 쉬프트한다. >> 연산자로 쉬프트 될때 빈자리는 부호를 지키기 위해 MSB 로 채워넣는다.

- 또한 >>> 가 있는데 이건 채우는것을 무조건 0 으로 채운다.

# 관계 연산자

- 관계 연산자는 ==, !=, <, >, <=, >=, instanceof 가 있다.

- instanceof : a instancof b 처럼 사용하며 a 의 참조 타입이 b 와 같으면 true, 다르면 false 리턴.


# 논리 연산자

- 논리 연산자는 ||(or), &&(and) 가 있다. 

- 논리 연산자의 피연산자들은 모두 boolean 타입이어야 한다.

- || 는 첫번째 연산자가 참이면 두번째 연산자를 검사하지 않고 첫번째 연산자가 거짓이어도 두번째 연산자를 검사한다.

- && 는 첫번째 연산자가 거짓이면 두번째 연산자를 검사하지 않고 첫번째 연산자가 참이어도 두번째 연산자를 검사한다.


# instanceof

- instanceof : a instancof b 처럼 사용하며 a 의 참조 타입이 b 와 같으면 true, 다르면 false 리턴.

- 보통 레퍼런스 타입의 변수가 다른 레퍼런스 타입의 변수로 변환이 가능한지 체크할 때 사용한다.

# assignment(=) operator

- 대입 연산자는 우선순위가 연산자 중에 가장 낮다.

- 오른쪽에서 왼쪽으로 연산 순서가 진행된다.

- 다른 연산자와 결합해서 사용할 수 있다.

```java
int i = j = 3; // j 에 3 이 저장되고 i 에 j 가 저장된다.

i <<= 5; // i = i << 5; 
i += = 5; // i = i + 5;
```


# 화살표(->) 연산자

- ->(람다)는 Java 8 부터 등장 했으며, 기존의 익명 클래스 객체를 만드는 대신 메소드를 1급 시민으로 하여 값으로 전달 하는 개념과 함께 등장했다.

- 메소드를 하나의 식으로 표현함으로서 함수를 간결하고 간단하게 표현 할 수 있게 되었다.

- 아래는 두 수의 최대값을 구하는 메소드를 화살표 연산자를 통해 구현한 예제이다.

```java
// 기존 메소드 선언 & 사용 방식
public int max(int a, int b) {
  return a > b ? a : b;
}
int i = max(10, 20);

// 화살표 연산자(람다) 활용
(int a, int b) -> {return a > b ? a : b;}

// 반환 값이 있는 경우 생략이 가능하다
(int a, int b) -> {a > b ? a : b;}

// {} 안의 식이 1줄이면 {} 도 생략 가능하다. 이 때 ; 도 빼줘야 한다. 나는 보통 {} 를 생략하지 않는 편이다.
(int a, int b) -> a > b ? a : b

// 또한 매개변수의 타입마저 생략이 가능하다. 추론이 가능한 경우에만.
(a, b) -> a > b ? a : b
```


# 3항 연산자

- ? 와 : 를 사용한 연산자이다. 조건 ? A : B; 처럼 사용하며 조건이 참이면 A 아니면 B 가 리턴된다.

```java
// x 값이 0 보다 크면 1, 0 이면 0, 0 보다 작으면 -1 을 값이 넣는 3항 연산자
int result = x > 0 ? 1 : (x == 0 ? 0 : -1); // 3항 연산자 2개를 중첩해서 사용.
```


# 연산자 우선 순위

- 수학에서 연산자 우선 순위가 있듯이 java 에서도 우선 순위가 있다.

- () 를 적극 활용해서 명시적으로 우선순위를 구분하는 습관을 들이자.

- 우선 순위는 레퍼런스 참고 (https://donologue.tistory.com/53)


# Java 13. switch 연산자

- 기존의 switch 문을 연산자로 사용 할 수 있게 됐다.

- : 를 -> 로 사용하며 break; 생략이 가능하다.

- 또한 변수로 할당할 수 있으며 yield 를 이용하여 값을 리턴할 수도 있다.

```java
int i = switch(n) {
  case 1 -> {
    System.out.println("one");
    yield 1;
  }
  case 10 -> {
    System.out.println("ten");
    yield 10;
  }
  default -> {
    System.out.println("many");
    yield 100;
  }
}
```