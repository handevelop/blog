---
title:  "끄적 끄적.."
excerpt: "이런 질문이 들어온다면?"

categories:
  - 스터디
last_modified_at: 2020-05-16T08:06:00-05:00
---


# JVM 이 뭔가요? 어떻게 동작하나요?

- JVM 은 자바 버추얼 머신의 약자입니다.

- java 이전에 있었던 C 와 같은 프로그래밍 언어는 컴파일 된 파일이 OS 종속적이었습니다.

- 그래서 컴파일 된 OS 위에서만 구동되는 단점이 있었습니다. 새로운 OS 에서 작동 시키기 위해서는 다시 컴파일 했어야 하니까요.

- 그러나 java 는 JVM 을 이용해 위의 단점을 해결했습니다. 어떤 OS 든 JVM 만 설치 되어 있으면 그 위에서 java 컴파일러로 컴파일 된 클래스 파일을 실행시키면 되니까요.

- 동작과정은 다음과 같습니다.

- Hello.java 파일을 java 컴파일러로 컴파일을 하면 Hello.class 라는 클래스 파일이 생성됩니다. 이는 한줄 한줄이 1바이트라서 바이트코드 라고도 합니다.

- 이 바이트코드를 JVM 의 구성요소 중 한개인 클래스 로더가 런타임 메모리 영역으로 올립니다.

- 런타임 메모리 영역은 메소드가 저장되어 있는 메소드 영역, `new` 키워드를 통해 새로운 객체가 저장되는 힙 영역, 메소드의 호출,리턴 정보가 저장되는 스택 영역, 다음에 수행 될 명령어가 저장되어 있는 PC 레지스터 영역, 하드웨어 제어 등을 위해 다른 언어로 작성된 기능을 사용하고 기록하는 네이티브 메소드 영역이 있습니다.

- 메소드 영역과 힙 영역은 모든 쓰레드가 공유하지만 스택 영역과 PC 레지스터 영역, 네이티브 메소드 영역은 개별 쓰레드 할당됩니다.

- 이제 바이트코드가 JVM 의 런타임 메모리 영역에 올라간 바이트코드를 검사하여 변조되지 않았다면 JVM 의 다른 구성요소인 실행엔진에 의해 바이트코드가 한줄씩 수행됩니다. 이 과정에서 GC 의 작동과 쓰레드 동기화가 일어납니다.

- 실행엔진의 구성요소는 인터프리터, JIT 컴파일러, GC로 불리우는 가비지컬렉터가 있습니다.

- 가비지컬렉터는 힙 영역에 할당된 객체중 참조되지 않은 객체를 제거하는 역할을 합니다. 에덴, 서바이브0, 서바이브1 로 구성된 뉴 제네레이션 영역과 올드 제네레이션 영역으로 되어 있습니다.

- 막 객체가 등록되면 에덴 영역에 배치되고 계속 참조가 되어 살아남게 되면 서바이브0(또는 1) -> 올드 제네레이션 으로 이동하게 됩니다.


# @Transactional 이란?

- Spring 에서 제공하는 애노테이션으로 메소드나 클래스에 선언할 수 있습니다.

- propagation 옵션은 트랜잭션 동작 도중 다른 트랜잭션을 호출할 때, 어떻게 할 것인지 지정하는 옵션입니다.

- rollbackFor 옵션은 해당 클래스의 예외 발생 시 롤백하는 옵션입니다.

- isolation 옵션은 일관성 없는 데이터 허용 수준을 설정하는 옵션입니다.

- 타임아웃 시간을 설정하는 timeout, 쓰기 작업을 만나면 예외를 일으키게 하는 readOnly 옵션도 있습니다.


# List, ArrayList, LinkedList 차이점?

- 먼저 Array 는 하나의 변수에 여러개의 값을 넣기 위한 정적 리스트입니다.

- List 는 java 콜렉션 프레임워크(JCF) 중 하나입니다.

- ArrayList, LinkedList 모두 이 List 콜렉션을 구현한 구현체입니다.

- ArrayList 는 Array 랑 비슷하게 인덱스로 객체를 관리합니다. 하지만 Array 랑 다르게 길이가 동적입니다. 처음에 설정한 길이가 있고 그 저장 공간보다 더 많은 객체가 들어오면 두배씩 증가합니다.

- LinkedList 는 인덱스로 객체를 관리하지 않고 참조를 링크해서 체인처럼 관리합니다. Array, ArrayList 의 단점인 delete, insert 시 발생하는 shift 에 대한 오버헤드를 해결하기 위한 자료구조입니다.

- Vector 는 ArrayList 랑 동일한 자료구조 형태를 띄고 있지만 동기화가 되어 있어 쓰레드 세이프합니다. 그렇기 때문에 ArrayList 보다 추가,삭제 과정이 느리다는 단점이 있습니다.


# 불변객체란?

- 객체가 생성 되고나서 더 이상 변경되지 않는 객체를 말합니다.

- 대표적으로 `String, Boolean, Integer` 등이 있습니다.

- 실제로는 스트링을 우리는 바꾸면서 사용하는데, 사실 이는 새로운 객체를 계속 만드는 것입니다.

- 한번 생성되면 더이상 변하지 않기 때문에 동기화 되어있어 쓰레드 세이프합니다.

- 단점으로는 계속 스트링 타입 변수를 재할당하면 새로운 객체를 만드므로 성능저하와 메모리 누수가 발생합니다.

- 불변 객체를 만들기 위해서는 클래스 안의 멤버 변수를 final 로 선언하고 setter 를 구현하지 않으면 됩니다.


# JCF 에는 뭐가 있는가?

- 크게 보자면 Collection.List, Collection.Set, Map, Queue 가 있습니다.

- List 는 순서가 있으며 중복을 허용하지만 Set 은 순서가 없고 중복을 허용하지 않습니다.

- Map 은 key-value 구조로 되어 있으며 key 는 중복을 허용하지 않습니다.

- Map 의 key 는 set 의 특성을 갖고, value 는 list 의 특성을 가집니다. 그래서 그런지 map 의 메소드 중 keySet() 이 있는 것 같습니다.

- Queue 는 먼저들어온 것이 먼저 나가는 자료구조입니다.


# 우선순위 큐란?

- Queue 의 구현체로 FIFO 의 특성을 갖지 않고 우선순위가 큰 큐를 먼저 처리합니다.


# Map 자료구조 설명해주세요

- key-value 형태의 자료구조로 대표적인 구현체는 HashTable, HashMap, TreeMap 이 있습니다.

- 해시테이블은 해시맵보다 느리지만 동기화를 제공합니다. 그리고 key 나 value 에 null 이 불가능합니다.

- 해시맵은 해시테이블과 다르게 동기화를 제공하지 않고 key, value 에 null 이 가능합니다.

- 트리맵은 키를 추가할 때 내부적으로 정렬을 합니다. 그렇기 때문에 삽입 할 때 상대적으로 시간이 더 소요되지만 정렬되어 있기에 검색이 좀 더 빠릅니다.


# 프로세스와 쓰레드의 차이?

- 프로세스는 OS 에서 수행되는 프로그램을 부르는 단위입니다.

- 쓰레드는 프로세스 안에서 수행되는 작업의 흐름 단위입니다. 프로세스 1개당 여러개의 쓰레드를 가질 수 있습니다. 이를 멀티 쓰레드라 합니다.

- 멀티 프로세스는 OS 에서 여러개의 프로세스를 실행하는 것을 말합니다. 멀티 프로세스는 각각의 프로세스가 독립된 메모리를 할당 받기 때문에 한 프로세스가 비정상적인 종료가 있어도 다른 프로세스에 영향을 주지 않습니다.

- 하지만 멀티 쓰레드의 경우 힙 메모리를 공유하여 쓰기 때문에 한개의 쓰레드에 문제가 생기면 다른 쓰레드에 문제를 야기할 수 있습니다.


# Http 란? Https 와의 차이점은?

- Http 란 Hyper text transfer protocol 로 웹 환경에서 정보를 주고받기 위한 프로토콜입니다. 클라이언트 - 서버와의 통신을 할 때 HttpStatus 를 확인하여 요청이 성공했는지 실패했는지를 알 수 있습니다.

- 2xx 은 요청이 성공, 4xx 는 요청이 잘못되어 서버가 해당 요청을 수행하지 않았음을, 5xx 는 서버 오류로 수행 할 수 없음을 나타냅니다.

- 또한 HttpStatus 뿐 아니라 Http Method 를 사용하여 클라이언트 - 서버간 통신하는데요. 

- 헤더만 채워서 주로 HTML 문서를 요청하는 HEAD, 쿼리스트링으로 파라미터를 넘겨 자원을 요청하는 GET, body 에 그 내용을 숨겨서 보내는 POST, 갱신하고 싶은 내용을 body에 넣어 내용을 갱신하는 PUT, 삭제를 요청하는 DELETE 등이 있습니다. 

- Https 는 http 에 secure 가 추가된 것으로 기존의 http 가 가지고 있던 통신시에 정보를 암호화하지 않는다는 점을 보완한 프로토콜입니다. 시큐어 소켓 레이어를 사용하여 SSL 인증서를 이용하며 민감한 정보를 암호화 합니다.


# Spring DI, AOP, IOC 란?

- DI 는 Dependency Injection 으로 의존성 주입이라고 하는데, 이는 프레임워크에 의해 객체의 의존성이 주입되는 것을 말합니다.

- AOP 는 Aspect Oriented Programming 의 약자로 여러 메소드에서 공통적으로 수행하는 코드를 하나로 묶어 코드 밖에 개발을 해두고 메소드가 실행하기전, 실행 후 등 실행시점에 따라 기능을 적용하는 프로그래밍 방법입니다.

- IOC 는 Inversion Of Control 즉, 제어의 역전으로 어플리케이션이 가지는 객체의 제어권을 IOC 컨테이너가 가진다 하여 IOC 라 부릅니다.


# @SpringBootApplication 란?

- `@SpringBootConfiguration` 와 `@ComponentScan` 와 `@EnableAutoConfiguration` 가 결합된 어노테이션입니다.

- 컴포넌트 스캔은 `@Component, @RestController, @Controller, @Service, @Configuration, @Repository` 등의 어노테이션을 가진 빈들을 스캔해서 빈 등록 합니다.

- EnableAutoConfiguration 은 스프링 팩토리즈에 등록된 Configuration 들을 조건에 따라 빈 등록 합니다.


# Spring AOP, filter, interceptor 의 차이

- 브라우저에서 서버로 요청을 보내면 filter -> interceptor -> AOP, interceptor -> filter 순으로 동작합니다.

- filter 는 dispatcherSevlet 으로 요청이 가기전에 실행되고

- interceptor 는 controller 로 요청이 가기전에 실행됩니다.

- 그래서 주로 인코딩, XSS 처리 등을 필터에서 처리하고 인증이나 권한 같은 로직을 인터셉터에서 처리합니다.

- AOP 는 주로 controller 요청 이후 비즈니스 로직에서 처리됩니다. 주로 로깅, 트랜잭션, 에러 처리 등을 공통으로 수행하는 부분을 수행합니다.

- @Transactional 또한 프록시 기반의 Spring AOP 기법을 활용한 어노테이션입니다.


# OOP 란?

- Object Oriented Programming 으로 현실 세계에 존재하는 객체를 소프트웨어에서 표현하기 위해 상속성 추상화 캡슐화 다형성이라는 특성을 이용하는 프로그래밍 기법입니다.

- 상속성 : 상위 클래스에 의거하여 새로운 클래스를 정의할 수 있는 특성입니다.

- 추상화 : 공통된 부분을 묶는 것을 추상화 라고 합니다.

- 캡슐화 : 클래스를 정의할 때 관련성 있는 필드와 메소드로 묶는 것을 캡슐화라고 합니다.

- 다형성 : 오버로딩, 오버라이딩 등으로 기존 소스를 확장하거나 변경하는 것을 가능하게 해줍니다.
